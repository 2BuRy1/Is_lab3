/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.6.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package systems.project.controllers.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Generated;
import jakarta.validation.Valid;

import jakarta.validation.constraints.NotNull;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import systems.project.models.Ticket;
import systems.project.models.api.AbstractResponse;
import systems.project.models.api.CloneRequest;
import systems.project.models.api.ImportResult;
import systems.project.models.api.SellRequestDTO;
import systems.project.models.envelopes.TicketsEnvelope;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen",
        date = "2025-09-21T19:04:05.004649+03:00[Europe/Moscow]",
        comments = "Generator version: 7.6.0")
@Validated
@Tag(name = "Tickets", description = "the Tickets API")
public interface TicketsApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * POST /add_ticket : Создать билет
     *
     * @param ticket (required)
     * @return Создано (status code 200)
     * or Ошибка валидации/создания (status code 400)
     */
    @Operation(
        operationId = "addTicket",
        summary = "Создать билет",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Создано", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Ошибка валидации/создания", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/add_ticket",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    CompletableFuture<ResponseEntity<AbstractResponse<Ticket>>> addTicket(
        @Parameter(name = "Ticket", description = "", required = true) @Valid @RequestBody Ticket ticket
    );


    /**
     * POST /clone_vip : Клонировать билет как VIP (цена * 2)
     *
     * @param cloneRequest  (required)
     * @return Копия создана (status code 200)
     *         or Не найден исходный билет/ошибка (status code 400)
     */
    @Operation(
        operationId = "cloneVip",
        summary = "Клонировать билет как VIP (цена * 2)",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Копия создана", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Не найден исходный билет/ошибка", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/clone_vip",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Ticket>>> cloneVip(
        @Parameter(name = "CloneRequest",
                description = "",
                required = true)
        @Valid
        @RequestBody CloneRequest cloneRequest
    );


    /**
     * GET /count_comment_less : Подсчёт билетов с comment лексикографически меньше данного
     *
     * @param comment  (required)
     * @return Количество (status code 200)
     *         or Ошибка (status code 400)
     */
    @Operation(
        operationId = "countCommentLess",
        summary = "Подсчёт билетов с comment лексикографически меньше данного",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Количество", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Ошибка", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/count_comment_less",
        produces = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Integer>>> countCommentLess(
        @NotNull @Parameter(name = "comment",
                description = "",
                required = true,
                in = ParameterIn.QUERY)
        @Valid
        @RequestParam(value = "comment", required = true) String comment
    );


    /**
     * DELETE /delete_by_comment : Массовое удаление билетов по точному совпадению comment
     *
     * @param commentEq  (required)
     * @return Удалено (status code 200)
     *         or Ничего не найдено/ошибка (status code 400)
     */
    @Operation(
        operationId = "deleteByComment",
        summary = "Массовое удаление билетов по точному совпадению comment",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Удалено"),
            @ApiResponse(responseCode = "400", description = "Ничего не найдено/ошибка", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/delete_by_comment",
        produces = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Void>>> deleteByComment(
        @NotNull @Parameter(name = "commentEq",
                description = "",
                required = true,
                in = ParameterIn.QUERY)
        @Valid
        @RequestParam(value = "commentEq",
                required = true) String commentEq
    );


    /**
     * DELETE /delete_ticket/{id} : Удалить билет по ID
     *
     * @param id  (required)
     * @return Удалено (status code 200)
     *         or Не найдено/ошибка (status code 400)
     */
    @Operation(
        operationId = "deleteTicket",
        summary = "Удалить билет по ID",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Удалено"),
            @ApiResponse(responseCode = "400", description = "Не найдено/ошибка", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/delete_ticket/{id}",
        produces = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Void>>> deleteTicket(
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") Integer id
    );


    /**
     * GET /get_ticket/{id} : Получить билет по ID
     *
     * @param id  (required)
     * @return Найдено (status code 200)
     *         or Билет не найден (status code 400)
     */
    @Operation(
        operationId = "getTicketById",
        summary = "Получить билет по ID",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Найдено", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Билет не найден", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/get_ticket/{id}",
        produces = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Ticket>>> getTicketById(
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") Integer id
    );

    /**
     * GET /get_tickets : Получить список билетов
     *
     * @return Успех (status code 200)
     *         or Ошибка (status code 400)
     */
    @Operation(
        operationId = "getTickets",
        summary = "Получить список билетов",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Успех", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Ошибка", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/get_tickets",
        produces = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<TicketsEnvelope>>> getTickets();


    /**
     * POST /tickets/import : Импортировать список билетов
     *
     * @param ticketList  (required)
     * @return Импорт завершён (status code 200)
     *         or Ошибка импорта (status code 400)
     */
    @Operation(
        operationId = "importTickets",
        summary = "Импортировать список билетов",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Импорт завершён", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Ошибка импорта", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/tickets/import",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<ImportResult>>> importTickets(
        @Parameter(name = "ticketList", description = "", required = true)
        @Valid
        @RequestBody List<Ticket> ticketList
    );


    /**
     * GET /min_event_ticket : Билет с минимальным ID события
     *
     * @return Найдено (status code 200)
     *         or Не найдено (status code 400)
     */
    @Operation(
        operationId = "minEventTicket",
        summary = "Билет с минимальным ID события",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Найдено", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Не найдено", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/min_event_ticket",
        produces = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Ticket>>> minEventTicket();


    /**
     * POST /sell_ticket : Продать билет пользователю
     *
     * @param sellRequestDTO  (required)
     * @return Успех (status code 200)
     *         or Ошибка (status code 400)
     */
    @Operation(
        operationId = "sellTicket",
        summary = "Продать билет пользователю",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Успех", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Ошибка", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/sell_ticket",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Void>>> sellTicket(
        @Parameter(name = "SellRequestDTO",
                description = "",
                required = true)
        @Valid
        @RequestBody SellRequestDTO sellRequestDTO
    );


    /**
     * GET /tickets/stream : Подписка на события (SSE)
     * Поток серверных событий об изменениях сущностей.
     *
     * @return text/event-stream (status code 200)
     *         or Ошибка (status code 400)
     */
    @Operation(
        operationId = "streamTickets",
        summary = "Подписка на события (SSE)",
        description = "Поток серверных событий об изменениях сущностей.",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "text/event-stream", content = {
                @Content(mediaType = "text/event-stream", schema = @Schema(implementation = String.class)),
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            }),
            @ApiResponse(responseCode = "400", description = "Ошибка", content = {
                @Content(mediaType = "text/event-stream", schema = @Schema(implementation = AbstractResponse.class)),
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/tickets/stream",
        produces = { "text/event-stream", "application/text" }
    )

    SseEmitter stream();


    /**
     * POST /update_ticket/{id} : Обновить билет по ID
     *
     * @param id  (required)
     * @param ticket  (required)
     * @return Обновлено (status code 200)
     *         or Не найдено/ошибка (status code 400)
     */
    @Operation(
        operationId = "updateTicket",
        summary = "Обновить билет по ID",
        tags = { "Tickets" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Обновлено"),
            @ApiResponse(responseCode = "400", description = "Не найдено/ошибка", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AbstractResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/update_ticket/{id}",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    CompletableFuture<ResponseEntity<AbstractResponse<Void>>> updateTicket(
        @Parameter(name = "id",
                description = "",
                required = true,
                in = ParameterIn.PATH)
        @PathVariable("id") Integer id,
        @Parameter(name = "Ticket",
                description = "",
                required = true)
        @Valid
        @RequestBody Ticket ticket
    );

}
